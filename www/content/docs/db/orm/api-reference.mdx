---
title: API Reference
description: Complete API reference for Better-Convex ORM with functions, operators, and types
links:
  doc: https://orm.drizzle.team/docs/overview
---

import { InfoIcon, CheckCircle, Code } from "lucide-react"

This is the full API surface for Better‑Convex ORM. The goal is to match Drizzle v1’s relational query builder while adapting to Convex’s document model.

## Schema

### `convexTable()`

```ts
convexTable<TName extends string, TColumns>(
  name: TName,
  columns: TColumns,
  extraConfig?: (t) => [
    index('by_field').on(t.someField),
    searchIndex('by_text').on(t.title),
    vectorIndex('embedding_vec').on(t.embedding).dimensions(1536),
  ]
): ConvexTable<TableConfig<TName, TColumns>>
```

**Example**
```ts
const users = convexTable('users', {
  name: text().notNull(),
  email: text().notNull(),
  age: integer(),
});
```

**Auto‑generated fields**
- `_id: Id<TName>`
- `_creationTime: number`

### `index()` / `uniqueIndex()`

```ts
import { index, uniqueIndex } from 'better-convex/orm';

const posts = convexTable(
  'posts',
  {
    title: text().notNull(),
    authorId: id('users'),
  },
  (t) => [
    index('by_author').on(t.authorId),
    uniqueIndex('by_title').on(t.title),
  ]
);
```

### `unique()`

```ts
import { unique } from 'better-convex/orm';

const users = convexTable(
  'users',
  {
    firstName: text(),
    lastName: text(),
  },
  (t) => [unique('full_name').on(t.firstName, t.lastName)]
);
```

Use `.nullsNotDistinct()` to treat `null` as a value (PG parity).

### `foreignKey()`

```ts
import { foreignKey } from 'better-convex/orm';

const memberships = convexTable(
  'memberships',
  {
    userSlug: text().notNull(),
  },
  (t) => [foreignKey({ columns: [t.userSlug], foreignColumns: [users.slug] })]
);
```

Use `.onUpdate()` / `.onDelete()` for Drizzle API parity (no cascading behavior).
For non‑`_id` foreign keys, add an index on the referenced columns.

### `searchIndex()`

```ts
import { searchIndex } from 'better-convex/orm';

const posts = convexTable(
  'posts',
  {
    title: text().notNull(),
    authorId: id('users'),
  },
  (t) => [searchIndex('by_title').on(t.title).filter(t.authorId)]
);
```

Use `.staged()` to stage a search index for later activation.

### `vectorIndex()`

```ts
import { vector, vectorIndex } from 'better-convex/orm';

const posts = convexTable(
  'posts',
  {
    authorId: id('users'),
    embedding: vector(1536).notNull(),
  },
  (t) => [
    vectorIndex('embedding_vec')
      .on(t.embedding)
      .dimensions(1536)
      .filter(t.authorId),
  ]
);
```

Vector indexes require `.dimensions(n)` and can be staged with `.staged()`.

### `vector()`

```ts
vector(1536)
vector('embedding', 768)
```

### Column Modifiers

```ts
const users = convexTable('users', {
  slug: text().notNull(),
});

text().notNull()
text().default('member')
text().unique()
text().unique('handle_unique', { nulls: 'not distinct' })
id('users').references(() => users._id)
text().references(() => users.slug, { onDelete: 'cascade' })
```

### `defineRelations()`

```ts
defineRelations(schema, (r) => ({
  users: { posts: r.many.posts() },
  posts: {
    author: r.one.users({ from: r.posts.authorId, to: r.users._id }),
  },
}))
```

### `extractRelationsConfig()`

```ts
const ormEdges = extractRelationsConfig(ormSchema);
```

### `buildSchema()`

```ts
const ormSchema = buildSchema({ users, posts });
```

Builds a schema config without relations. Use this when you don’t need `with` loading.

## Database

### `createDatabase()`

```ts
createDatabase(db, ormSchema, ormEdges)
```

Creates a typed query/mutation client. If `db` is a writer context, mutation methods are available.

## Query Builder

### `findMany()`

```ts
await db.query.users.findMany({
  where: { role: 'admin' },
  orderBy: { _creationTime: 'desc' },
  limit: 10,
  offset: 0,
  with: { posts: true },
  columns: { name: true },
});
```

**Options**
- `where`: object filter (Drizzle v1 shape)
- `orderBy`: `{ field: 'asc' | 'desc' }`
- `limit`, `offset`
- `with`: relation loading
- `columns`: post‑fetch projection

### `findFirst()`

```ts
await db.query.users.findFirst({ where: { email: 'a@b.com' } });
```

### `paginate()`

```ts
await db.query.posts.paginate(
  { where: { published: true }, orderBy: { _creationTime: 'desc' } },
  { cursor: null, numItems: 20 }
);
```

## Query Filters (object `where`)

**Core operators**
- `eq`, `ne`, `gt`, `gte`, `lt`, `lte`
- `in`, `notIn`
- `isNull`, `isNotNull`
- `AND`, `OR`, `NOT`

**String operators (post‑fetch)**
- `like`, `ilike`, `notLike`, `notIlike`
- `startsWith`, `endsWith`, `contains`

## Mutations

### `insert()`

```ts
await db.insert(users).values({ name: 'Ada', email: 'ada@example.com' });
```

### `update()`

```ts
await db
  .update(users)
  .set({ name: 'Ada Lovelace' })
  .where(eq(users._id, userId));
```

### `delete()`

```ts
await db.delete(users).where(eq(users._id, userId));
```

### `returning()`

```ts
const [user] = await db
  .insert(users)
  .values({ name: 'Ada', email: 'ada@example.com' })
  .returning({ id: users._id, email: users.email });
```

### `onConflictDoUpdate()`

```ts
await db
  .insert(users)
  .values({ email: 'ada@example.com', name: 'Ada' })
  .onConflictDoUpdate({
    target: users.email,
    set: { name: 'Ada Lovelace' },
  });
```

## Filter Expression Helpers

Use these in mutation `where(...)` clauses:

```ts
eq(field, value)
ne(field, value)
gt(field, value)
gte(field, value)
lt(field, value)
lte(field, value)
inArray(field, values)
notInArray(field, values)
and(...filters)
or(...filters)
not(filter)
isNull(field)
isNotNull(field)
```

## Type Helpers

```ts
InferSelectModel<typeof users>
InferInsertModel<typeof users>
users.$inferSelect
users.$inferInsert
```

## Notes

- `columns` projection is post‑fetch
- String operators are post‑fetch
- `paginate()` uses the first `orderBy` field for cursor ordering
