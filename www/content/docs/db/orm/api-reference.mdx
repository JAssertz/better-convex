---
title: API Reference
description: Complete API reference for Better-Convex ORM with functions, operators, and types
links:
  doc: https://orm.drizzle.team/docs/overview
---

import { InfoIcon, CheckCircle, Code } from "lucide-react"

This is the full API surface for Better‑Convex ORM. The goal is to match Drizzle v1’s relational query builder while adapting to Convex’s document model.

## Schema

### `convexTable()`

```ts
convexTable<TName extends string, TColumns>(
  name: TName,
  columns: TColumns,
  extraConfig?: (t) => [
    index('by_field').on(t.someField),
    uniqueIndex('by_unique').on(t.someField),
    check('check_name', gt(t.someField, 0)),
    searchIndex('by_text').on(t.title),
    vectorIndex('embedding_vec').on(t.embedding).dimensions(1536),
  ]
): ConvexTable<TableConfig<TName, TColumns>>
```

**Example**
```ts
const users = convexTable('users', {
  name: text().notNull(),
  email: text().notNull(),
  age: integer(),
});
```

**Auto‑generated fields**
- `_id: Id<TName>`
- `_creationTime: number`

### `convexTable.withRLS()`

```ts
convexTable.withRLS(name, columns, (t) => [
  rlsPolicy('policy_name', {
    for: 'select',
    using: (ctx) => eq(t.ownerId, ctx.viewerId),
  }),
])
```

Enables RLS for the table. If RLS is enabled and no permissive policies apply,
access is denied by default.

### `index()` / `uniqueIndex()`

```ts
import { index, uniqueIndex } from 'better-convex/orm';

const posts = convexTable(
  'posts',
  {
    title: text().notNull(),
    authorId: id('users'),
  },
  (t) => [
    index('by_author').on(t.authorId),
    uniqueIndex('by_title').on(t.title),
  ]
);
```

### `unique()`

```ts
import { unique } from 'better-convex/orm';

const users = convexTable(
  'users',
  {
    firstName: text(),
    lastName: text(),
  },
  (t) => [unique('full_name').on(t.firstName, t.lastName)]
);
```

Use `.nullsNotDistinct()` to treat `null` as a value (PG parity).

### `foreignKey()`

```ts
import { foreignKey } from 'better-convex/orm';

const memberships = convexTable(
  'memberships',
  {
    userSlug: text().notNull(),
  },
  (t) => [foreignKey({ columns: [t.userSlug], foreignColumns: [users.slug] })]
);
```

Use `.onUpdate()` / `.onDelete()` to configure foreign key actions.
Actions are enforced at runtime by Better-Convex ORM mutations.

For `cascade` / `set null` / `set default`, add an index on the referencing columns.
Without an index, Better-Convex will throw when it detects referencing rows.

### `check()`

```ts
import { check, convexTable, gt, integer } from 'better-convex/orm';

const users = convexTable(
  'users',
  {
    age: integer(),
  },
  (t) => [check('adult_age', gt(t.age, 18))]
);
```

Checks are enforced at runtime by Better-Convex ORM mutations and follow SQL-like NULL semantics (the check fails only when the expression is `false`).

### `searchIndex()`

```ts
import { searchIndex } from 'better-convex/orm';

const posts = convexTable(
  'posts',
  {
    title: text().notNull(),
    authorId: id('users'),
  },
  (t) => [searchIndex('by_title').on(t.title).filter(t.authorId)]
);
```

Use `.staged()` to stage a search index for later activation.

### `vectorIndex()`

```ts
import { vector, vectorIndex } from 'better-convex/orm';

const posts = convexTable(
  'posts',
  {
    authorId: id('users'),
    embedding: vector(1536).notNull(),
  },
  (t) => [
    vectorIndex('embedding_vec')
      .on(t.embedding)
      .dimensions(1536)
      .filter(t.authorId),
  ]
);
```

Vector indexes require `.dimensions(n)` and can be staged with `.staged()`.

### `vector()`

```ts
vector(1536)
vector('embedding', 768)
```

### Column Modifiers

```ts
const users = convexTable('users', {
  slug: text().notNull(),
});

text().notNull()
text().default('member')
text().$type<'admin' | 'member'>()
number().$defaultFn(() => Date.now())
number().$onUpdateFn(() => Date.now())
text().unique()
text().unique('handle_unique', { nulls: 'not distinct' })
id('users').references(() => users._id)
text().references(() => users.slug, { onDelete: 'cascade' })
```

### `rlsPolicy()`

```ts
rlsPolicy(name, {
  as: 'permissive' | 'restrictive',
  for: 'all' | 'select' | 'insert' | 'update' | 'delete',
  to: 'public' | 'current_user' | RlsRole | string | Array<...>,
  using: (ctx, t) => FilterExpression<boolean>,
  withCheck: (ctx, t) => FilterExpression<boolean>,
})
```

`using` controls read/update/delete visibility. `withCheck` controls insert/update
values. When omitted, `withCheck` falls back to `using`.

### `rlsRole()`

```ts
rlsRole('admin', { createRole: true }).existing();
```

### `defineRelations()`

```ts
defineRelations(schema, (r) => ({
  users: { posts: r.many.posts() },
  posts: {
    author: r.one.users({ from: r.posts.authorId, to: r.users._id }),
  },
}))
```

### `extractRelationsConfig()`

```ts
const ormEdges = extractRelationsConfig(ormSchema);
```

### `buildSchema()`

```ts
const ormSchema = buildSchema({ users, posts });
```

Builds a schema config without relations. Use this when you don’t need `with` loading.

## Database

### `createDatabase()`

```ts
createDatabase(db, ormSchema, ormEdges)
```

Creates a typed query/mutation client. If `db` is a writer context, mutation methods are available.

**RLS options**

```ts
createDatabase(db, ormSchema, ormEdges, {
  rls: {
    ctx,
    roleResolver: (ctx) => ctx.roles ?? [],
  },
})
```

Use `db.skipRules.table` for an explicit bypass of RLS.

## Query Builder

### `findMany()`

```ts
await db.query.users.findMany({
  where: { role: 'admin' },
  orderBy: { _creationTime: 'desc' },
  limit: 10,
  offset: 0,
  with: { posts: true },
  columns: { name: true },
});
```

**Options**
- `where`: object filter (Drizzle v1 shape)
- `orderBy`: `{ field: 'asc' | 'desc' }`
- `limit`, `offset`
- `with`: relation loading
- `columns`: post‑fetch projection
- `extras`: post‑fetch computed fields

### `findFirst()`

```ts
await db.query.users.findFirst({ where: { email: 'a@b.com' } });
```

### `paginate()`

```ts
await db.query.posts.paginate(
  { where: { published: true }, orderBy: { _creationTime: 'desc' } },
  { cursor: null, numItems: 20 }
);
```

## Query Filters (object `where`)

**Core operators**
- `eq`, `ne`, `gt`, `gte`, `lt`, `lte`
- `in`, `notIn`
- `isNull`, `isNotNull`
- `AND`, `OR`, `NOT`

**String operators (post‑fetch)**
- `like`, `ilike`, `notLike`, `notIlike`
- `startsWith`, `endsWith`, `contains`

## Mutations

### `insert()`

```ts
await db.insert(users).values({ name: 'Ada', email: 'ada@example.com' });
```

### `update()`

```ts
await db
  .update(users)
  .set({ name: 'Ada Lovelace' })
  .where(eq(users._id, userId));
```

### `delete()`

```ts
await db.delete(users).where(eq(users._id, userId));
```

**Delete helpers**
```ts
// Soft delete (sets deletionTime)
await db.delete(users).where(eq(users._id, userId)).soft();

// Cascade behavior for FK actions
await db.delete(users).where(eq(users._id, userId)).cascade({ mode: 'hard' });

// Scheduled delete (soft now, hard later)
await db
  .delete(users)
  .where(eq(users._id, userId))
  .scheduled({ delayMs: 60_000 });
```

Scheduled deletes require passing `{ scheduler, scheduledDelete }` to `createDatabase`
and exposing `scheduledDeleteFactory(schema, edges)` as an internal mutation.

### `returning()`

```ts
const [user] = await db
  .insert(users)
  .values({ name: 'Ada', email: 'ada@example.com' })
  .returning({ id: users._id, email: users.email });
```

### `onConflictDoUpdate()`

```ts
await db
  .insert(users)
  .values({ email: 'ada@example.com', name: 'Ada' })
  .onConflictDoUpdate({
    target: users.email,
    set: { name: 'Ada Lovelace' },
  });
```

## Filter Expression Helpers

Use these in mutation `where(...)` clauses:

```ts
eq(field, value)
ne(field, value)
gt(field, value)
gte(field, value)
lt(field, value)
lte(field, value)
inArray(field, values)
notInArray(field, values)
and(...filters)
or(...filters)
not(filter)
isNull(field)
isNotNull(field)
```

## Type Helpers

```ts
InferSelectModel<typeof users>
InferInsertModel<typeof users>
users.$inferSelect
users.$inferInsert
```

## Introspection Helpers

```ts
getTableColumns(users) // includes _id/_creationTime
getTableConfig(users)  // indexes/unique/fks/rls/checks
```

## Notes

- `columns` projection is post‑fetch
- String operators are post‑fetch
- `extras` are computed post‑fetch
- `paginate()` uses the first `orderBy` field for cursor ordering
