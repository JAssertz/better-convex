---
title: Limitations & Performance
description: Understand Better-Convex ORM limitations, workarounds, and performance characteristics
links:
  doc: https://docs.convex.dev/database
---

import { InfoIcon, AlertTriangle, CheckCircle, Zap } from "lucide-react"

Better-Convex mirrors Drizzle v1’s relational query builder on top of Convex’s document database. That means a few SQL-only features do not apply, and some features are implemented post-fetch for API parity.

## Not Available In Convex

These Drizzle features are SQL-specific and do not map to Convex:

- SQL joins
- Raw SQL execution
- RQB SQL-only features: `RAW` filters and SQL placeholders in `where`/`limit`/`offset` are not supported at runtime
- Database migrations and database-side constraints/triggers
- Custom SQL data types

## Post-Fetch Behavior

These features keep Drizzle’s API shape but run after data is fetched:

**Column selection**
```ts
const users = await db.query.users.findMany({
  columns: { name: true, email: true },
});
```

**String operators**
```ts
const users = await db.query.users.findMany({
  where: { email: { ilike: '%@example.com' } },
});
```

**Extras (computed fields)**
```ts
const users = await db.query.users.findMany({
  extras: {
    emailDomain: (row) => row.email.split('@')[1]!,
  },
});
```

**Relation filters on `many()`**
```ts
const users = await db.query.users.findMany({
  with: {
    posts: {
      where: { published: true },
      orderBy: { _creationTime: 'desc' },
      limit: 5,
    },
  },
});
```

## Indexes And Ordering

- `paginate()` relies on the first `orderBy` field for cursor ordering
- Sorting without an index falls back to `_creationTime` ordering
- Add `index('...').on(t.field)` on fields used for filter or sort

```ts
const posts = convexTable(
  'posts',
  {
    title: text().notNull(),
    numLikes: number().notNull(),
  },
  (t) => [index('by_likes').on(t.numLikes)]
);
```

## Constraints And Defaults

- Unique, foreign keys, and `check()` constraints are enforced only through Better‑Convex ORM mutations
- Foreign key actions require an index on the referencing columns
- Check constraints follow SQL-like NULL semantics: the check fails only when the expression is `false` (and passes on `unknown`)
- Defaults are applied only by Better‑Convex ORM inserts/updates (`.default(...)`, `$defaultFn(...)`, `$onUpdateFn(...)`)
- Direct `ctx.db` writes bypass all ORM enforcement

## Soft & Scheduled Deletes

- Soft/scheduled deletes are **optional helpers** and not part of Drizzle v1
- Soft deletes require a `deletionTime` field in your table
- Scheduled deletes require `createDatabase(..., { scheduler, scheduledDelete })`

## Performance Guidance

- Index every field you filter or order by frequently
- Use search indexes for large text filtering
- Use vector indexes only for embedding search
- Prefer `paginate()` for infinite scroll and large datasets
- Avoid deep offset pagination for large tables
- Use `with` to avoid N+1 queries

## Common Gotchas

| Issue | Cause | Fix |
|---|---|---|
| Slow ordering | Missing index | Add `index('...').on(t.field)` in schema |
| `paginate()` order changes | No index on primary sort | Add index on first `orderBy` field |
| `like` or `ilike` is slow | Post-fetch filtering | Use search indexes |
| Relations not loading | Missing edges | Export `ormSchema` and `ormEdges` |
| Missing defaults | Direct `ctx.db` bypasses ORM defaults | Use ORM inserts or set defaults in code |

## Schema Introspection

Better-Convex exposes Drizzle-style helpers for runtime schema metadata:

```ts
import { getTableColumns, getTableConfig } from 'better-convex/orm';

const columns = getTableColumns(users); // includes _id/_creationTime
const config = getTableConfig(users);   // indexes/unique/fks/rls/checks
```

## Next Steps

<Cards>
  <Card title="Schema Definition" href="/docs/db/orm/schema">
    Define tables, relations, and indexes
  </Card>
  <Card title="Querying Data" href="/docs/db/orm/queries">
    Learn filters, ordering, and pagination
  </Card>
</Cards>
