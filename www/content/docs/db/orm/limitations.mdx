---
title: Limitations & Performance
description: Understand Better-Convex ORM limitations, workarounds, and performance characteristics
links:
  doc: https://docs.convex.dev/database
---

import { InfoIcon, AlertTriangle, CheckCircle, Zap } from "lucide-react"

Better-Convex mirrors Drizzle v1’s relational query builder on top of Convex’s document database. That means a few SQL-only features do not apply, and some features are implemented post-fetch for API parity.

## Not Available In Convex

These Drizzle features are SQL-specific and do not map to Convex:

- SQL joins
- Raw SQL execution
- Database migrations and SQL-level constraints (checks, cascading actions)
- Custom SQL data types
- Table introspection helpers (`getTableConfig`, `getTableColumns`)

## Post-Fetch Behavior

These features keep Drizzle’s API shape but run after data is fetched:

**Column selection**
```ts
const users = await db.query.users.findMany({
  columns: { name: true, email: true },
});
```

**String operators**
```ts
const users = await db.query.users.findMany({
  where: { email: { ilike: '%@example.com' } },
});
```

**Relation filters on `many()`**
```ts
const users = await db.query.users.findMany({
  with: {
    posts: {
      where: { published: true },
      orderBy: { _creationTime: 'desc' },
      limit: 5,
    },
  },
});
```

## Indexes And Ordering

- `paginate()` relies on the first `orderBy` field for cursor ordering
- Sorting without an index falls back to `_creationTime` ordering
- Add `index('...').on(t.field)` on fields used for filter or sort

```ts
const posts = convexTable(
  'posts',
  {
    title: text().notNull(),
    numLikes: number().notNull(),
  },
  (t) => [index('by_likes').on(t.numLikes)]
);
```

## Constraints And Defaults

- Unique and foreign keys are enforced only through Better‑Convex ORM mutations
- Non‑`_id` foreign keys require an index on the referenced columns
- Check constraints and cascading actions are not enforced
- Defaults are applied only by Better‑Convex ORM inserts
- Use application logic or transaction rules to enforce constraints

## Performance Guidance

- Index every field you filter or order by frequently
- Use search indexes for large text filtering
- Use vector indexes only for embedding search
- Prefer `paginate()` for infinite scroll and large datasets
- Avoid deep offset pagination for large tables
- Use `with` to avoid N+1 queries

## Common Gotchas

| Issue | Cause | Fix |
|---|---|---|
| Slow ordering | Missing index | Add `index('...').on(t.field)` in schema |
| `paginate()` order changes | No index on primary sort | Add index on first `orderBy` field |
| `like` or `ilike` is slow | Post-fetch filtering | Use search indexes |
| Relations not loading | Missing edges | Export `ormSchema` and `ormEdges` |
| Missing defaults | Direct `ctx.db` bypasses ORM defaults | Use ORM inserts or set defaults in code |

## Next Steps

<Cards>
  <Card title="Schema Definition" href="/docs/db/orm/schema">
    Define tables, relations, and indexes
  </Card>
  <Card title="Querying Data" href="/docs/db/orm/queries">
    Learn filters, ordering, and pagination
  </Card>
</Cards>
